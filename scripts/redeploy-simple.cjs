const { ethers } = require("ethers");
const fs = require("fs");
const path = require("path");
const solc = require("solc");

/**
 * Simple redeployment script for ZSwap with correct encrypted token addresses
 * Uses existing Mock tokens, deploys new Encrypted wrappers and ZSwap
 */

// Existing deployed addresses
const EXISTING = {
  MockUSDC: "0x594c461bf180258E292bb68e77C643dc96e4E5F0",
  MockUSDT: "0x4B9A2d935b81890599fbbbbD7821A594C67Fafe3"
};

// Load contracts
function compileContract(contractName, sourceFile) {
  console.log(`üìù Compiling ${contractName}...`);
  const source = fs.readFileSync(sourceFile, "utf8");
  
  const input = {
    language: "Solidity",
    sources: {
      [contractName]: {
        content: source
      }
    },
    settings: {
      outputSelection: {
        "*": {
          "*": ["abi", "evm.bytecode"]
        }
      },
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  };
  
  const output = JSON.parse(solc.compile(JSON.stringify(input)));
  
  if (output.errors) {
    output.errors.forEach(err => {
      if (err.severity === "error") {
        console.error(err.formattedMessage);
        process.exit(1);
      }
    });
  }
  
  const contract = output.contracts[contractName][contractName.split(".")[0]];
  return {
    abi: contract.abi,
    bytecode: contract.evm.bytecode.object
  };
}

async function main() {
  console.log("üöÄ Redeploying ZSwap with Correct Addresses on Sepolia...\n");
  
  // Setup provider and wallet
  const provider = new ethers.JsonRpcProvider(process.env.SEPOLIA_RPC_URL);
  const wallet = new ethers.Wallet(process.env.DEPLOYER_PRIVATE_KEY, provider);
  
  console.log("üìù Deploying with account:", wallet.address);
  const balance = await provider.getBalance(wallet.address);
  console.log("üí∞ Account balance:", ethers.formatEther(balance), "ETH\n");
  
  console.log("‚ôªÔ∏è  Using existing Mock tokens:");
  console.log("   MockUSDC:", EXISTING.MockUSDC);
  console.log("   MockUSDT:", EXISTING.MockUSDT);
  
  const deployed = { ...EXISTING };
  
  // Compile contracts
  const encUSDC = compileContract("EncryptedUSDCSimple.sol", "contracts/tokens/EncryptedUSDCSimple.sol");
  const encUSDT = compileContract("EncryptedUSDTSimple.sol", "contracts/tokens/EncryptedUSDTSimple.sol");
  const zswap = compileContract("ZSwapSimple.sol", "contracts/core/ZSwapSimple.sol");
  
  // STEP 1: Deploy ZSwap with placeholder addresses first
  console.log("\n1Ô∏è‚É£  Deploying ZSwap (temporary with placeholders)...");
  const ZSwapTemp = new ethers.ContractFactory(zswap.abi, zswap.bytecode, wallet);
  const zswapTempContract = await ZSwapTemp.deploy(ethers.ZeroAddress, ethers.ZeroAddress);
  await zswapTempContract.waitForDeployment();
  const tempZSwapAddress = await zswapTempContract.getAddress();
  console.log("   ‚úÖ Temporary ZSwap deployed to:", tempZSwapAddress);
  
  // STEP 2: Deploy EncryptedUSDC (referencing temporary ZSwap)
  console.log("\n2Ô∏è‚É£  Deploying EncryptedUSDC...");
  const EncUSDC = new ethers.ContractFactory(encUSDC.abi, encUSDC.bytecode, wallet);
  const encUSDCContract = await EncUSDC.deploy(EXISTING.MockUSDC, tempZSwapAddress);
  await encUSDCContract.waitForDeployment();
  deployed.EncryptedUSDC = await encUSDCContract.getAddress();
  console.log("   ‚úÖ EncryptedUSDC deployed to:", deployed.EncryptedUSDC);
  
  // STEP 3: Deploy EncryptedUSDT (referencing temporary ZSwap)
  console.log("\n3Ô∏è‚É£  Deploying EncryptedUSDT...");
  const EncUSDT = new ethers.ContractFactory(encUSDT.abi, encUSDT.bytecode, wallet);
  const encUSDTContract = await EncUSDT.deploy(EXISTING.MockUSDT, tempZSwapAddress);
  await encUSDTContract.waitForDeployment();
  deployed.EncryptedUSDT = await encUSDTContract.getAddress();
  console.log("   ‚úÖ EncryptedUSDT deployed to:", deployed.EncryptedUSDT);
  
  // STEP 4: Deploy FINAL ZSwap with correct encrypted token addresses
  console.log("\n4Ô∏è‚É£  Deploying FINAL ZSwap (with correct addresses)...");
  const ZSwapFinal = new ethers.ContractFactory(zswap.abi, zswap.bytecode, wallet);
  const zswapContract = await ZSwapFinal.deploy(deployed.EncryptedUSDC, deployed.EncryptedUSDT);
  await zswapContract.waitForDeployment();
  deployed.ZSwapPool = await zswapContract.getAddress();
  console.log("   ‚úÖ FINAL ZSwap deployed to:", deployed.ZSwapPool);
  
  // STEP 5: Configure ZSwap
  console.log("\n‚öôÔ∏è  Configuring contracts...");
  console.log("   üìù Authorizing deployer as AVS operator...");
  const tx = await zswapContract.setAVSAuthorization(wallet.address, true);
  await tx.wait();
  console.log("   ‚úÖ AVS operator authorized");
  
  // Save addresses
  const configPath = path.join(__dirname, "../config/contracts.ts");
  const configContent = `// Auto-generated by deployment script
export const CONTRACTS = {
  MockUSDC: "${deployed.MockUSDC}",
  MockUSDT: "${deployed.MockUSDT}",
  EncryptedUSDC: "${deployed.EncryptedUSDC}",
  EncryptedUSDT: "${deployed.EncryptedUSDT}",
  ZSwapPool: "${deployed.ZSwapPool}",
  chainId: 11155111,
  explorerUrl: "https://sepolia.etherscan.io",
} as const;
`;
  
  fs.writeFileSync(configPath, configContent, "utf-8");
  
  // Print summary
  console.log("\n" + "=".repeat(60));
  console.log("üéâ ZSwap Redeployment Complete!");
  console.log("=".repeat(60));
  console.log("\nüìã Deployed Contract Addresses:");
  console.log("   MockUSDC (existing):  ", deployed.MockUSDC);
  console.log("   MockUSDT (existing):  ", deployed.MockUSDT);
  console.log("   EncryptedUSDC (NEW):  ", deployed.EncryptedUSDC);
  console.log("   EncryptedUSDT (NEW):  ", deployed.EncryptedUSDT);
  console.log("   ZSwapPool (NEW):      ", deployed.ZSwapPool);
  console.log("\nüîó View on Etherscan:");
  console.log("   https://sepolia.etherscan.io/address/" + deployed.ZSwapPool);
  console.log("\n‚úÖ Addresses saved to: config/contracts.ts");
  console.log("\n‚ö†Ô∏è  Note: Old EncryptedUSDC/USDT contracts are now orphaned.");
  console.log("   Users should deposit to NEW encrypted token contracts.");
  console.log("=".repeat(60) + "\n");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n‚ùå Deployment failed:");
    console.error(error);
    process.exit(1);
  });
